---
title: 'HTTP 1.1 Reference - Semantics and Content (2) (최종 수정 날짜 : 2021-02-07)'
tags: Web HTTP1.1
categories: http
author: CY
key: HTTP 1.1 Reference - Semantics and Content (2)
---
# 참고 자료
* 이병록님이 번역하신 HTTP 1.1 Semantics and Content 번역본  
  [https://roka88.dev/106](https://roka88.dev/106)
* MDN Web Docs  
  [https://developer.mozilla.org/ko/docs/Web/HTTP](https://developer.mozilla.org/ko/docs/Web/HTTP)

이외 자료는 내용 중 링크 추가
##### 틀린 내용, 부족한 내용 꼭 지적 부탁드립니다!

# 1. Request Methods
## 1.1 Overview
Request 메소드 토큰은 Request 요청에서 가장 큰의미를 나타내며 클라이언트가 요청을 한 목적과 성공적인 결과로 클라이언트가 기대하는것을 나타낸다.
(GET 요청을 했다면 리소스를 가져오는 목적이였을 것이며, 반환 값으로는 해당 리소스를 원했을 것이다)
Request 메소드의 의미론은 Request에 어떠한 헤더 필드가 있을 때, 추가된 의미론과 메소드가 충돌되지 않는 경우 더 적합할 수 있다. 예를 들어 클라이언트는 조건부 요청 헤더 필드를 보내 대상 리소스의 현재 상태를 조건으로 요청된 작업을 수행 할 수 있다.

`method = token`

HTTP는 원래 분산 객체 시스템에 대한 인터페이스로 사용할 수 있도록 설계 되었다. 요청 메소드는 식별된 객체에 대해 정의된 메소드를 호출하는 것과 거의 동일한 방법으로 대상 리소스에 의미론을 적용하도록 구상 되었다. 메소드 토큰은 대소문자를 구분한다. 왜나하면 대소문자를 구분하는 객체 기반 시스템의 게이트웨이로 사용될 수 있기 때문이다.

분산된 객체와 달리, HTTP의 표준화된 요청 메소드는 리소스에 특정하지 않는다. 적합한 인터페이스는 네트워크 기반 시스템[REST]에서 더 나은 가시성과 재사용을 제공하기 때문이다. 표준화된 메소드는 어떠한 리소스에 적용될때 같은 의미론을 가진다. 각 리소스는 이러한 의미론이 구현되는지, 허용되는지는 자체적으로 결정한다. (개발자가 해당 메소드를 구현하냐 마냐에 대한 얘기인듯.)

다음 표에는 요약된 바와 같이 HTTP에서 일반적으로 사용되는 다수의 표준화된 메서드를 정의한다. 표준화된 메서드는 대문자 US-ASCII 문자로 정의된다.

Method  | Description
:------ | :-------
GET     | 대상 리소스의 현재 Representation을 전송
HEAD    | GET과 동일하나, status-line과 header부분만 전송
POST    | 요청 페이로드에서 리소스의 구체적인 처리 수행
PUT     | 대상 리소스의 모든 현재 Representation을 요청 페이로드로 대체
DELETE  | 대상 리소스의 현재 Representation 모두 제거
CONNECT | 대상 리소스로 식별된 서버에 대한 터널 설립
OPTIONS | 대상 리소스에 대한 통신 옵션 설명
TRACE   | 대상 리소스의 경로를 따라 메시지 루프백 테스트를 수행

모든 범용 서버는 GET 및 HEAD 메서드를 지원해야한다. 다른 메서드는 선택사항이다.

이 명세 범위를 벗어난 추가 메서드는 HTTP에서 사용할 수 있도록 표준화되었다. 이러한 모든 메서드는 IANA에 의해 유지 되는 "Hypertext TransferProtocol (HTTP) Method Registry” 내에 등록되어야 한다.

대상 리소스가 허용되는 메서드 집합은 Allow 헤더 필드에 나열할 수 있다. 그러나 허용된 메서드 집합은 동적으로 변할 수 있다. 서버에서 인식되지 않거나 구현되지 않은 요청 메서드가 수신되면 서버는 501(Not Implemented) 상태 코드로 응답해야 한다. 서버에서 구현은 되어 있지만 대상 리소스에 대해 사용 할 수 없는 메소드라면 서버는 405(Method Not Allowed) 상태 코드로 응답해야 한다.

## 4.2. Common Method Properties
### 4.2.1. Safe Methods
요청 메서드는 정의된 의미론이 읽기 전용인경우 'safe'로 간주한다. 예를 들어 리소스에 대해서 safe 한 method를 적용한 결과는 서버의 어떠한 상태변화에 대해서 요구하지도 기대하지도 않는다. 마찬가지로 safe method의 합리적인 사용은 서버에 어떠한 위협과 비정상적인 행위를 야기하지 않을것이다.

이러한 safe methods는 완전한 읽기 전용이 아니거나, 호출하는 동안 부작용을 일으키는 행동을 구현하는것을 막지 않는다. 중요한 것은 클라이언트가 추가 행동을 요구하지 않았고 이에 대한 책임을 물을 수 없기 때문에 안전하게 구현을 해야한다. 예를 들어 대부분 서버는 메서드 관계없이 모든 응답이 완료될 때 로그파일에 액세스 하기 위해 요청 정보를 추가하며, 로그 저장소가 가득 차서 서버가 다운될 수 있더라도 안전하다고 간주된다. 마찬가지로 웹에서 광고를 선택하여 시작된 safe 요청은 종종 광고 계정에 요금을 청구하는 부작용을 낳을 것이다.

이 명세에 의해 정의된 요청 메소드 중 GET, HEAD, OPTION, TRACE 메서드는 안전하다고 정의된다.

안전한 메서드와 안전하지 않은 메서드를 구분하는 목적은 자동 검색 프로세스(spider)와 캐시 성능 최적화(pre-fetching)가 문제를 일으키질 않도록 하기 위함이다. 또한 잠재적으로 신뢰할 수 없는 콘텐츠를 처리할 때 안전하지 않은 메서드의 자동 사용에 적절한 제약 조건을 적용할 수 있도록 한다.

사용자 에이전트는 사용자에게 잠재적 행동을 제시할 때 사용자가 요청하기 전에 안전하지 않은 메서드를 인지할 수 있도록 안전한 메서드와 안전하지 않은 메서드를 구분해야 한다. 

유효한 요청 URI 내의 매개변수가 action 선택의 영향을 미치도록 리소스를 구성할 때, action이 요청 메소드의 의미와 일치하는지 확인하는 것은 리소스 소유자의 책임이다. 예를 들어 웹 기반 콘텐츠 편집 소프트웨어는 "page?do=delete"와 같은 쿼리 매개변수 내의 작업을 사용하는 것이 일반적이다. 이러한 리소스의 목적이 안전하지 않은 작업을 수행하는 것이라면, 리소스 소유자는 안전한 요청 메소드를 사용하여 액세스할 때 해당 작업을 비활성화하거나 허용하지 않아야 한다. 그렇게 하지 않으면 자동화된 프로세스가 링크 유지보수, pre-fetching (어플리케이션의 성능 향상을 위해서 구동에 필요한 데이터를 메모리에 먼저 올려 놓는것.), 검색 인덱스 작성 등을 위해 모든 URI 참조에 대해 GET을 수행할 떄 적절하지 못한 부작용을 초래할 수 있다.

### 4.2.2 Idempotent Methods
요청 메서드는 해당 메서드를 여러번 요청했을때와 한번 요청했을때의 결과가 동일 한 경우, "idempotent"으로 간주된다(멱등성) 이 명세에 의해 정의된 요청 메서드 중 PUT, DELETE, 및 safe method는 멱등하다.

안전함의 정의와 마찬가지로, 멱등의 속성은 사용자가 요청한 것에만 적용된다. 서버는 각 요청을 별도로 로깅하거나, 버전 기록을 유지하거나 또는 각각 멱등 요청에서 비 멱-등한 결과를 구현하는것은 자유롭다.

멱등 메서드는 클라이언트가 서버의 응답을 읽기 전에 통신 장애가 발생하면 요청이 자동으로 반복될 수 있기 때문에 구별된다. 예를 들어 클라이언트가 PUT 요청을 보내고 응답이 수신되기 전에 기본 커넥션이 닫히면 클라이언트는 새로운 커넥션을 설정하고 멱등한 요청을 재시도할 수 있다. 응답은 다를수 있지만, 이전의 요청이 성공했더라도, 우리는 요청을 반복하는 것은 의도된 것과 같은 효과를 낸 다는것을 알고 있다.

### 4.2.3. Cacheable Methods
요청 메소드는 "cacheable"로 정의하여 향후 재사용에 대한 응답을 저장할 수 있다. 일반적으로 현재(아마 현재 상태와 의존하는 뜻인듯)와 권한 있는 응답에 의존하지 않는 safe 메서드는 캐시 가능으로 정의 된다. GET, HEAD 및 POST를 캐시 가능으로 정의하지만, 압도적으로 캐시구현은 GET와 HEAD만 지원한다. (POST는 safe method가 아니라고 했는데 뭐지?? 어떠한 상태 변화도 하지 않는 POST 요청은 괜찮다는건가?)

## 4.3. Method Definitions
### 4.3.1 GET
