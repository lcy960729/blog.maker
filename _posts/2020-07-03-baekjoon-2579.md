---
title: "백준 - 2579번 : 계단 오르기"
tags: DynamicProgramming baekjoon algorithm
categories: algorithm
author: CY
---

# 문제 설명

## [백준 2579번 계단 오르기](https://www.acmicpc.net/problem/2579)

전체적인 문제 설명은 위에 링크에서 확인하고 중요한 조건들만 확인 해보겠다.

![pic1](https://www.acmicpc.net/upload/images/f62omMF2kQYD5rDct.png)

1. 계단은 한 번에 한 계단 또는 두 계단씩 오를 수 있다.
2. 연속된 세 개의 계단을 모두 밟을 수 없다.
3. 마지막 도착 계단은 반드시 밟아야한다.
4. 시작할때 첫번째 계단부터 밟을 필요는 없다. 두번째 계단부터 밟을 수도 있다.
5. 계단을 밟으면 쓰여진 점수 얻게 된다. 얻을 수 있는 점수의 최대값을 구해야한다.

## 입력

첫번째는 계단의 수, 두번째 줄은 계단의 쓰여진 점수가 주어진다.

## 제한 조건

제한 조건으로는 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10000이하의 자연수이다.

---

# 이찬영

## 풀이 내용

이번 문제는 재귀로 구현 하였다.
dp는 도착 계단에서 부터 첫번째 계단으로 내려가며 구현 하였고  
재귀가 끝날때마다 최대값을 memo배열에 저장하도록 했다.

dp를 들여다 보면 4가지의 조건이 있다.

1. `if (n==0)` 재귀가 마지막 바닥에 닿았을때, 재귀의 끝을 알려 주는 조건이다.  
   n == 0 이므로 맨 처음 밟은 계단이며 첫번째 계단의 점수를 반환 한다.

2. `if (n < 0)` n < 0 이전 계단에서 2칸을 건너 뛰어 첫번째 계단을 밟지 못했을때 이다. 0을 리턴하여 최댓값에 영향을 주지 않도록 구현 했다.

3. `if (memoValue != -1)` 동적 프로그래밍의 핵심이다. 이미 지금까지의 계단을 내려올때 최대값을 저장해두었기 때문에 값이 존재 할 경우 바로 저장한 값을 리턴한다.

4. `if (count == 1)` 연속된 계단을 두번 밟았을 때이다. 이 경우에는 다음 계단을 무조건 두칸 뛰어넘게 구현 하였다.  
   아닐 경우는 한칸 내려간 경우와 두칸 내려간 경우를 모두 구하여 최대값을 선택하였다.

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;

int arr[300];
int memo[300][2];

long long dp(int n, int count){
    int &memoValue = memo[n][count];

    if (n == 0)
        return arr[n];

    if (n < 0)
        return 0;

    if (memoValue != -1){
        return memoValue;
    }

    long long ret;
    if (count == 1){
        ret = dp(n-2, 0);
    }else{
        ret = max(dp(n-1, count+1), dp(n-2, 0));
    }

    memoValue = ret + arr[n];
    return memoValue;
}

int main(){
    int n;
    cin >> n;
    memset(memo, -1 ,sizeof(memo));

    for (int i = 0; i < n; i++){
        cin >> arr[i];
    }

    cout << dp(n-1, 0);
}
```

---

# 이현직

## 풀이 내용

바닥부터 시작하여 계단을 한 칸씩 올라갔을 때의 최대 점수와 두 칸씩 올라갔을 때의 최대 점수를 재귀를 통해 계산하여 최대 점수를 반환하는 f 함수를 만들었다.
f 함수의 인자인 n은 n번째 계단을 의미하며, cnt는 연속으로 올라간 횟수를 나타낸다.

재귀의 탈출조건은 다음과 같이 4개가 있다.

1. `if(cnt == 3)`  
   문제의 조건에서 한 칸씩 올라가는 경우 '연속된 세 개의 계단을 모두 밟을 수 없다'라는 조건을 만족시키기 위해서 연속으로 3번 올라간 경우 -5000000의 점수를 반환하도록 하였다.  
   300개 이하의 계단과 10000점 이하의 자연수인 점수로 이루어져 있으므로 매우 작은 수를 반환한다.

1. `if(n == num)`  
   num은 처음에 주어진 계단의 개수를 의미하는 데, 재귀 함수를 거치면서 마지막 계단에 올라온 경우에는 마지막 계단의 점수를 반환하도록 하였다.

1. `if(n == num+1)`  
   재귀를 돌면서 2칸씩 올라가는 경우 마지막 계단을 건너 뛰고 그 다음칸에 가는 경우가 발생한다. 이 경우에는 '마지막 도착 계단은 반드시 밟아야한다'는 조건을 만족시키지 못하기 때문에 -5000000의 점수를 반환하도록 하였다.

1. `if(ret != 0)`  
   계단을 올라가면서 이전에 계산한 값을 미리 memo 배열에 저장해 두었는데 다시 계산하지 않고 이전에 계산한 값을 바로 반환하는 조건이다.

```cpp
#include <iostream>
#include <algorithm>

using namespace std;
int memo[4][301];
int input[301];
int num;

int f(int n, int cnt) {
	int u1, u2;

	if (cnt == 3)
		return -5000000;
	if (n == num)
		return input[n];
	if (n == num + 1)
		return -5000000;
	int& ret = memo[cnt][n];
	if (ret != 0)
		return ret;

	u1 = f(n + 1, cnt + 1) + input[n];
	u2 = f(n + 2, 1) + input[n];
	ret = max(u1, u2);
	return ret;
}
int main() {
	cin >> num;
	for (int i = 1; i <= num; i++) {
		cin >> input[i];
	}
	cout << f(0, 0);
}
```
